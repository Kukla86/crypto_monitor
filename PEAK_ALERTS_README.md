# 🔥 Система алертов с пиковыми значениями

## 📋 Обзор

Новая система алертов работает по принципу **"относительного изменения"** - каждый следующий алерт сравнивается с пиковым значением предыдущего алерта, а не с базовой точкой отсчета. Это предотвращает спам алертов при небольших колебаниях и обеспечивает более точное отслеживание значимых изменений.

## 🎯 Основные принципы

### 1. **Пиковые значения**
- Система хранит пиковые цены и объемы для каждого токена
- После отправки алерта точка отсчета обновляется на текущие значения
- Следующий алерт сравнивается с последним отправленным алертом

### 2. **Защита от спама**
- Минимальные интервалы между алертами (10-30 минут)
- Валидация подозрительно больших изменений
- Кэширование отправленных алертов

### 3. **Относительные изменения**
- Цена: сравнивается с последним алертом по цене
- Объем: сравнивается с последним алертом по объему
- Поддержка как роста, так и падения

## 📊 Пороги алертов

### Цена (относительно последнего алерта)

| Уровень | Порог | Интервал | Описание |
|---------|-------|----------|----------|
| **CRITICAL** | +20% | 30 мин | Критический рост цены |
| **WARNING** | +12% | 15 мин | Значительный рост цены |
| **INFO** | +8% | 10 мин | Умеренный рост цены |
| **WARNING** | -15% | 15 мин | Значительное падение цены |

### Объем (относительно последнего алерта)

| Уровень | Порог | Интервал | Описание |
|---------|-------|----------|----------|
| **WARNING** | +100% | 30 мин | Критический рост объема |
| **INFO** | +60% | 20 мин | Значительный рост объема |

## 🔧 Техническая реализация

### Основные функции

```python
# Получение пиковых значений
peak = get_peak_values(symbol)

# Установка пиковых значений
set_peak_values(symbol, price, volume, alert_type)

# Вычисление относительного изменения
change = calculate_relative_change(current_value, reference_value)

# Проверка необходимости обновления пика
should_update = should_update_peak(symbol, current_price, current_volume)
```

### Структура данных

```python
peak_values = {
    'symbol': {
        'price': 0.0,              # Пиковая цена
        'volume': 0.0,             # Пиковый объем
        'last_alert_time': 0,      # Время последнего алерта
        'last_price_alert': 0.0,   # Цена последнего алерта по цене
        'last_volume_alert': 0.0   # Объем последнего алерта по объему
    }
}
```

### База данных

Таблица `peak_values`:
```sql
CREATE TABLE peak_values (
    symbol TEXT PRIMARY KEY,
    peak_price REAL DEFAULT 0.0,
    peak_volume REAL DEFAULT 0.0,
    last_alert_time INTEGER DEFAULT 0,
    last_price_alert REAL DEFAULT 0.0,
    last_volume_alert REAL DEFAULT 0.0,
    updated_at INTEGER DEFAULT 0
);
```

## 🚀 Примеры работы

### Сценарий 1: Постепенный рост цены

1. **Начальное состояние**: Цена = $1.00
2. **Первый алерт** (+10%): Цена = $1.10 → Алерт INFO
3. **Второй алерт** (+8% от $1.10): Цена = $1.188 → Алерт INFO
4. **Третий алерт** (+12% от $1.188): Цена = $1.33 → Алерт WARNING

### Сценарий 2: Падение после роста

1. **Текущее состояние**: Цена = $1.33 (после роста)
2. **Алерт о падении** (-15% от $1.33): Цена = $1.13 → Алерт WARNING
3. **Следующий алерт**: сравнивается с $1.13, а не с $1.00

### Сценарий 3: Защита от спама

1. **Алерт отправлен**: Время = 10:00
2. **Попытка алерта в 10:05**: Отклонен (слишком рано)
3. **Попытка алерта в 10:15**: Разрешен (прошло 15 минут)

## 🛡️ Валидация и защита

### Проверки валидности

```python
# Подозрительно большие изменения
if abs(price_change) > 50:
    logger.warning("Подозрительно большое изменение цены - пропускаем")
    return

if abs(volume_change) > 300:
    logger.warning("Подозрительно большое изменение объема - пропускаем")
    return
```

### Временные ограничения

```python
# Минимальные интервалы между алертами
CRITICAL: 30 минут
WARNING: 15 минут  
INFO: 10 минут
```

### Кэширование

```python
# Кэш для предотвращения дублирования
alert_cache = {
    'alert_hash': timestamp,
    'symbol_price_value': timestamp,
    'symbol_volume_value': timestamp
}
```

## 📈 Преимущества новой системы

### ✅ Устранение спама
- Алерты отправляются только при значимых изменениях
- Каждый алерт имеет новую точку отсчета
- Защита от повторных алертов на том же уровне

### ✅ Точность отслеживания
- Относительные изменения более информативны
- Учет трендов и направлений движения
- Поддержка как роста, так и падения

### ✅ Гибкость настройки
- Настраиваемые пороги для каждого уровня
- Настраиваемые интервалы между алертами
- Возможность добавления новых типов алертов

### ✅ Надежность
- Сохранение состояния в базе данных
- Восстановление после перезапуска
- Обработка ошибок и исключений

## 🔄 Миграция с старой системы

### Автоматическая миграция
- При первом запуске создается таблица `peak_values`
- Существующие алерты не затрагиваются
- Новая логика применяется только к новым алертам

### Обратная совместимость
- Старые функции `get_alert_reference()` и `set_alert_reference()` сохранены
- Могут использоваться для других целей
- Не влияют на новую систему алертов

## 🧪 Тестирование

Запуск тестов:
```bash
python test_peak_alerts.py
```

Тесты проверяют:
- Инициализацию пиковых значений
- Симуляцию роста и падения цен
- Симуляцию изменения объемов
- Защиту от спама
- Работу реальной функции `check_alerts`

## 📝 Логирование

Система ведет подробные логи:
```
DEBUG: Относительное изменение цены FUEL: 8.50% (от $0.073100 до $0.079350)
INFO: Отправлен INFO алерт по цене для FUEL
DEBUG: Обновлены пиковые значения для FUEL: цена=$0.079350, объем=$316,506,198
```

## 🔧 Настройка

### Изменение порогов
```python
# В функции check_alerts
if price_change > 20:  # CRITICAL
if price_change > 12:  # WARNING  
if price_change > 8:   # INFO
if price_change < -15: # WARNING (падение)
```

### Изменение интервалов
```python
# Временные интервалы в секундах
CRITICAL: 1800  # 30 минут
WARNING: 900    # 15 минут
INFO: 600       # 10 минут
```

## 🎉 Результат

Новая система алертов обеспечивает:
- **Качественные уведомления** вместо спама
- **Точное отслеживание** значимых изменений
- **Гибкую настройку** под различные потребности
- **Надежную работу** с сохранением состояния

Система готова к использованию и полностью интегрирована в основной мониторинг! 